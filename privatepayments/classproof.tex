\begin{lemma}
  $\tnsfnkachina_{\vn{zc}}$ and $\vn{dep}_\vn{zc}$ satisfy \autoref{def:dep},
  and therefore the pair $(\tnsfn_\vn{zc},\allowbreak \lkgfn_\vn{zc}) \eqdef
  (\tnsfnmainkachina(\tnsfnkachina_\vn{zc}),
  \lkgfnmainkachina(\tnsfnkachina_\vn{zc}, \vn{desc}_\vn{zc},\allowbreak \vn{dep}_\vn{zc}))$
  is in the set $\classkachina$.
\end{lemma}

\begin{proof}[sketch]
  $\vn{desc}_{\mathsf{zc}}$ is a pure function, and $\tnsfnkachina_{\mathsf{zc}}$ is
  a function with oracle access to public and private state variables. More
  tricky is showing that $\vn{dep}_{\mathsf{zc}}$ satisfies its requirements.
  Transcripts generated by $\runtnsfn$ fall into three categories:
  They set a private key (initialization), they insert a coin (minting), or they
  remove a coin, and insert some number of coins (sending).

  Consider first a new initialization transaction. It does not affect the
  behavior of unconfirmed minting and sending transactions, as these do not use
  the current private state's secret key. Further, it cannot co-exist with
  another unconfirmed initialization transaction, as this would initialize the
  private keys, ensuring an abort, which violates the preconditions of
  dependencies.

  If the new transaction is a minting or balance transaction, this
  functions independently of other transactions, not having any requirements on
  the current private state. Likewise for sending transactions, the state
  transcript itself only depends on $\rho^{\{o,\pi\}}$, not the dynamic
  $\rho$. The only thing varying is which coins get added and removed from
  the set of available coins, but this information is not directly used -- its purpose is to
  reduce the necessary re-computation the next time around.
  \qed
\end{proof}
%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
